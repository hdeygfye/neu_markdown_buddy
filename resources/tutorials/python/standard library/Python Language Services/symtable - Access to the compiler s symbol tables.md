# symtable - Access to the compilerâ€™s symbol tables
## Table of Contents

1. [Example 1: Parsing Source Code](#example-1-parsing-source-code)
2. [Example 2: Extracting Function Names](#example-2-extracting-function-names)
3. [Example 3: Inspecting Node Attributes](#example-3-inspecting-node-attributes)
4. [Example 4: Extracting Variable Names](#example-4-extracting-variable-names)
5. [Example 5: Inspecting Node Types](#example-5-inspecting-node-types)
6. [Example 6: Extracting Comments](#example-6-extracting-comments)



The `symtable` module in Python is designed to provide access to the symbol tables generated by the Python parser. These symbol tables are useful for introspection and can be used to understand the structure of a program's code at compile time. However, it's important to note that the `symtable` module is deprecated as of Python 3.8 and may not be supported in future versions. For most modern use cases, you should consider using other libraries or techniques for introspection.

Below are some examples of how you might interact with the symbol tables using the `ast` module, which provides a way to parse Python source code into an abstract syntax tree (AST). While `symtable` is not directly available for ASTs in Python 3.8 and later, it can be used indirectly by understanding the structure of AST nodes.

### Example 1: Parsing Source Code

```python
import ast

# Sample Python code
source_code = """
def example_function(a, b):
    return a + b
"""

# Parse the source code into an AST
tree = ast.parse(source_code)

# Print the type and name of each node in the AST
for node in tree:
    print(f"Node Type: {type(node).__name__}, Node Name: {node.__class__.__name__}")
```

### Example 2: Extracting Function Names

```python
import ast

def extract_function_names(source_code):
    tree = ast.parse(source_code)
    
    function_names = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            function_names.add(node.name)
    
    return function_names

# Sample Python code
source_code = """
def example_function(a, b):
    return a + b

def another_example_function(c, d):
    e = c * d
"""

# Extract and print the function names
function_names = extract_function_names(source_code)
print("Function Names:", function_names)
```

### Example 3: Inspecting Node Attributes

```python
import ast

def inspect_node_attributes(source_code):
    tree = ast.parse(source_code)
    
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            print(f"Function Name: {node.name}")
            print("Arguments:")
            for arg in node.args.args:
                print(f"  - {arg.arg}")
            print("Returns:", node.returns)

# Sample Python code
source_code = """
def example_function(a, b):
    return a + b

def another_example_function(c, d):
    e = c * d
"""

# Inspect attributes of function nodes
inspect_node_attributes(source_code)
```

### Example 4: Extracting Variable Names

```python
import ast

def extract_variable_names(source_code):
    tree = ast.parse(source_code)
    
    variable_names = set()
    for node in ast.walk(tree):
        if isinstance(node, (ast.Name, ast.Attribute)):
            variable_names.add(node.id)
    
    return variable_names

# Sample Python code
source_code = """
a = 10
b = a + 20
c = "hello"
d = c * 3
"""

# Extract and print the variable names
variable_names = extract_variable_names(source_code)
print("Variable Names:", variable_names)
```

### Example 5: Inspecting Node Types

```python
import ast

def inspect_node_types(source_code):
    tree = ast.parse(source_code)
    
    for node in ast.walk(tree):
        print(f"Node Type: {type(node).__name__}")

# Sample Python code
source_code = """
a = 10 + 20
b = "hello"
c = a + b
"""

# Inspect the types of nodes in the AST
inspect_node_types(source_code)
```

### Example 6: Extracting Comments

```python
import ast

def extract_comments(source_code):
    tree = ast.parse(source_code)
    
    comments = []
    for node in ast.walk(tree):
        if isinstance(node, ast.Expr) and isinstance(node.value, ast.Str):
            comments.append(node.value.s)
    
    return comments

# Sample Python code with comments
source_code = """
a = 10 + 20  # This is a comment
b = "hello"  # Another comment
c = a + b
"""

# Extract and print the comments
comments = extract_comments(source_code)
print("Comments:", comments)
```

These examples demonstrate how to parse and inspect Python source code using the `ast` module, which provides a powerful way to interact with the abstract syntax tree of Python programs. While the `symtable` module is deprecated, understanding ASTs can be a useful tool for introspection in Python programs.
